<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Customer Call | AI Assistant</title>
  <link rel="stylesheet" href="/css/customer-phone.css">
</head>
<body>

  <div class="phone-app">
    
    <!-- SCREEN 1: START -->
    <div id="screen-start" class="screen active">
      <div class="logo-area">
        <div class="logo-circle">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: white;">
            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
          </svg>
        </div>
        <h1 class="app-title">AI Support</h1>
        <p class="app-subtitle">24/7 Voice Assistant</p>
      </div>
      
      <button id="btn-start-call" class="btn-large btn-start">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
        </svg>
        Call Agent
      </button>

      <p id="connection-status" style="margin-top: 1rem; color: #64748b; font-size: 0.8rem;"></p>
    </div>

    <!-- SCREEN 2: IN CALL -->
    <div id="screen-call" class="screen">
      <div class="contact-info">
        <div class="avatar-large">
          <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: white;">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
          </svg>
        </div>
        <div class="contact-name">AI Agent</div>
        <div class="call-status">00:00</div>
      </div>

      <div class="waveform" id="visualizer">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
      </div>

      <div class="controls">
        <button class="btn-control btn-end" id="btn-end-call">
          <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
             <path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7"/>
          </svg>
        </button>
      </div>
    </div>

    <!-- SCREEN 3: ENDED -->
    <div id="screen-end" class="screen">
      <div class="end-message">Call Ended</div>
      <p id="final-duration" style="color: #94a3b8; margin-bottom: 2rem;">Duration: 00:00</p>
      
      <button id="btn-call-again" class="btn-large btn-start" style="background: #2563eb;">
        Call Again
      </button>
    </div>

  </div>
  
  <script type="module">
    import { AudioManager } from '/js/audio-manager.js';

    class PhoneApp {
      constructor() {
        this.ws = null;
        this.sessionId = null;
        this.audioManager = new AudioManager();
        this.timerInterval = null;
        this.startTime = null;
        
        // UI Elements
        this.screens = {
          start: document.getElementById('screen-start'),
          call: document.getElementById('screen-call'),
          end: document.getElementById('screen-end')
        };
        
        this.statusText = document.getElementById('connection-status');
        this.timerText = document.querySelector('.call-status');
        this.visualizer = document.getElementById('visualizer');
        
        // Web Speech API for client-side transcription (workaround for Gemini not sending inputTranscription)
        this.speechRecognition = null;
        this.initSpeechRecognition();
        
        this.init();
      }
      
      initSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          console.warn('Web Speech API not supported in this browser');
          return;
        }
        
        this.speechRecognition = new SpeechRecognition();
        this.speechRecognition.continuous = true;
        this.speechRecognition.interimResults = false;
        this.speechRecognition.lang = 'en-US';
        
        this.speechRecognition.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            if (event.results[i].isFinal) {
              const transcript = event.results[i][0].transcript.trim();
              if (transcript && this.ws && this.ws.readyState === WebSocket.OPEN) {
                // Send customer speech text to server for supervisor display
                this.ws.send(JSON.stringify({
                  type: 'customer_speech',
                  text: transcript
                }));
              }
            }
          }
        };
        
        this.speechRecognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          // Restart on recoverable errors
          if (event.error === 'no-speech' || event.error === 'aborted') {
            this.restartSpeechRecognition();
          }
        };
        
        this.speechRecognition.onend = () => {
          // Auto-restart if call is still active
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.restartSpeechRecognition();
          }
        };
      }
      
      restartSpeechRecognition() {
        if (this.speechRecognition && this.ws && this.ws.readyState === WebSocket.OPEN) {
          try {
            this.speechRecognition.start();
          } catch (e) {
            // Already started, ignore
          }
        }
      }
      
      init() {
        // Button Listeners
        document.getElementById('btn-start-call').addEventListener('click', () => this.startCall());
        document.getElementById('btn-end-call').addEventListener('click', () => this.endCall());
        document.getElementById('btn-call-again').addEventListener('click', () => location.reload()); // Simple reload for fresh state
      }

      showScreen(name) {
        Object.values(this.screens).forEach(s => s.classList.remove('active'));
        this.screens[name].classList.add('active');
      }

      async startCall() {
        this.statusText.textContent = "Connecting...";
        
        try {
          // 1. Initialize Audio (Permissions)
          await this.audioManager.initialize();
          
          // 2. Connect WebSocket
          // 2. Connect WebSocket
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const host = window.location.host;
          
          // Generate Session ID if needed
          if (!this.sessionId) {
              this.sessionId = crypto.randomUUID();
          }

          const wsUrl = `${protocol}//${host}?role=customer&session=${this.sessionId}`;
          console.log('Connecting to:', wsUrl);

          this.ws = new WebSocket(wsUrl);
          
          this.ws.onopen = () => {
            console.log('Connected to server');
            this.statusText.textContent = "Connected!";
            this.showScreen('call');
            this.startTimer();
            this.startAudioStreaming();
            
            // Start speech recognition for supervisor transcript display
            if (this.speechRecognition) {
              try {
                this.speechRecognition.start();
                console.log('Speech recognition started');
              } catch (e) {
                console.warn('Speech recognition start error:', e);
              }
            }
            
            // Trigger visualizer
            this.visualizer.classList.add('active');
          };
          
          this.ws.onmessage = async (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.type === 'audio') {
                // Play audio from AI (data.data is base64 encoded PCM)
                const pcmData = this.base64ToInt16(data.data);
                await this.audioManager.playAudio(pcmData);
              } else if (data.type === 'ai_response') {
                  // Ignore text response for phone UI
              }
            } catch (e) {
              console.error('Error processing message:', e);
            }
          };
          
          this.ws.onclose = () => {
            console.log('Disconnected');
            this.endCall();
          };
          
          this.ws.onerror = (e) => {
            console.error('WebSocket Error:', e);
            this.statusText.textContent = "Connection Error";
          };

        } catch (err) {
          console.error('Start call failed:', err);
          this.statusText.textContent = "Error: " + err.message;
        }
      }

      startAudioStreaming() {
        // Start capturing microphone and sending to WS
        this.audioManager.startRecording((audioData) => {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            // CRITICAL: Audio must be base64 encoded for Gemini Live API
            const base64Audio = this.int16ToBase64(audioData);
            this.ws.send(JSON.stringify({
              type: 'audio',
              data: base64Audio
            }));
          }
        });
      }

      // Convert Int16Array to base64 string (required by Gemini Live API)
      int16ToBase64(int16Array) {
        const bytes = new Uint8Array(int16Array.buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
      }

      // Convert base64 string back to Int16Array (for audio playback)
      base64ToInt16(base64String) {
        const binary = atob(base64String);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return new Int16Array(bytes.buffer);
      }

      endCall() {
        this.stopTimer();
        this.visualizer.classList.remove('active');
        
        // Stop speech recognition
        if (this.speechRecognition) {
          try {
            this.speechRecognition.stop();
          } catch (e) {
            // Ignore stop errors
          }
        }
        
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        
        this.audioManager.stopRecording();
        this.showScreen('end');
      }

      startTimer() {
        this.startTime = Date.now();
        this.timerText.textContent = "00:00";
        this.timerInterval = setInterval(() => {
          const delta = Date.now() - this.startTime;
          const seconds = Math.floor(delta / 1000) % 60;
          const minutes = Math.floor(delta / 60000);
          this.timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);
      }

      stopTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
        // Update final duration
        const durationText = this.timerText.textContent;
        document.getElementById('final-duration').textContent = `Duration: ${durationText}`;
      }
    }

    // Initialize
    window.phoneApp = new PhoneApp();
  </script>
</body>
</html>
